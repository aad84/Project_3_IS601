<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <style>
        * {
            box-sizing: border-box;
        }

        /* Style the body */
        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 0;
            background-image: url("images/back.jpg");
            background-color: white;
            background-position: center top;
            background-repeat: repeat-y;
            background-size: contain;
        }

        /* Header/logo Title */
        .header {
            padding-top: 35px;
            padding-bottom: 1px;
            text-align: center;
            color: white;
            font-size: 35px;
            background-color: rgba(70,10,92,0.85);
        }

        /* Style the top navigation bar */
        .navbar {
            display: flex;
            float: right;
            padding: 14px 20px;
            background: rgba(0,0,0,0.0);
        }

        /* Style the navigation bar links */
        .navbar a {
            color: white;
            padding: 14px 20px;
            text-decoration: none;
            text-align: center;
            font-size: 22px;
            font-weight: bold;
        }

        /* Change color on hover */
        .navbar a:hover {
            background-color: white;
            color: rebeccapurple;
        }

        .logo {
            color: white;
            float: left;
            padding: 21px 20px;
            text-decoration: none;
            text-align: center;
            font-size: 3vw;
            font-weight: bold;
            position: absolute;
        }

        /* Column container */
        .row {
            display: flex;
            flex-wrap: wrap;
        }

        /* Create two unequal columns that sits next to each other */
        /* Sidebar/left column */
        .side {
            flex:25%;
            background-color: rgba(70,10,92,0.75);
            padding: 20px;
            color: white;
        }

        /* Main column */
        .main {
            flex:75%;
            background-color: rgba(255,255,255,0.8);
            color: rebeccapurple;
            text-align: left;
            padding-left: 75px;
            padding-right: 75px;
        }

        .responsive {
            width: 100%;
            max-width: 510px;
            height: auto;
        }
        .footer a:hover {
            background-color: white;
            color: rgba(70,10,92,0.75);
        }

        /* Footer */
        .footer {
            padding: 20px;
            text-align: center;
            background: rgba(70,10,92,0.75);
            color: #E1F1FF;
            font-weight: bold;
        }

        a:link, a:visited {
            text-align: center;
            text-decoration: none;
            display: inline-block;
            color: #E1F1FF;
            padding: 6px 20px;
            font-size: 20px;
        }

        a:hover, a:active {
            background-color: #E1F1FF;
            color: #0060A8;
        }

        /* image, just for this example */
        img {
            vertical-align:bottom
        }




        p {
            font-size: 30px;
        }
        h2 {
            font-size: 45px;
        }
        h4 {
            font-size: 38px;
        }
        h6 {
            font-size: 50px;
            margin: 0 0;
            padding: 21px;
        }
        /* Responsive layout - when the screen is less than 700px wide, make the two columns stack on top of each other instead of next to each other */
        @media only screen and (max-width: 748px) {
            .side {
                width: 100%;
            }
            .main {
                width: 100%;
                padding-left: 50px;
                padding-right: 50px;
            }
            .row {
                flex-direction: column;
            }

        }
        @media screen and (max-width: 828px) {
            .logo {
                font-size: 25px;
            }

            .navbar {
                flex-direction: column;
            }

        }
        @media screen and (min-width: 1100px) {
            .logo {
                font-size: 33px;
            }
        }
        @media screen and (max-width: 600px) {
            img {
                vertical-align: text-bottom;
            }
        }

    </style>
</head>
<body>
<!-- Navigation Bar -->
<div class="logo">Object Oriented Programming</div>
<div class="navbar">
    <a href="index.html">Home</a>
</div>
<!-- Header -->
<div class="header">
    <h1>SOLID Object Oriented Design</h1>
    <h3 style="margin-bottom: 42px">About Design Principles</h3>
</div>
<article>
    <!-- The flexible grid (content) -->
    <div class="row">
        <div class="side">
            <h2 style="font-size: 42px;margin-top: 0;text-align: center;padding-top: 19px">Why to Design?</h2>
            <h4 style="margin-bottom: 20px;text-align: center">Concept</h4>
            <img alt="atomic" class="responsive" src="images/solid.png" style="float:right;clear:right;padding: 20px 20px 35px 20px">
            <p style="padding-left: 25px;padding-right: 25px">The broad goal of the SOLID principles is to reduce dependencies so that engineers change one area of software without impacting others. Additionally, they're intended to make designs easier to understand, maintain, and extend.</p>

        </div>
        <div class="main">
            <h2>SOLID </h2>
            <p>
                In object-oriented design, the SOLID principles are the five
                design principles that help to make the code cleaner, more flexible, and easier to
                change. The principles were compiled by Robert C. Martin.The name SOLID is an acronym,
                made up of the names of five principles. They are as follow</p><br>

            *<b>S</b>ingle responsibility principle (SRP),<br>
            *<b>O</b>pen-closed principle (OCP),<br>
            *<b>L</b>iskov substitution principle (LSP),<br>
            *<b>I</b>nterface segregation principle (ISP), and<br>
            *<b>D</b>ependency inversion principle (DIP).<br>

            <h2>Single Responsibility Principle </h2>

            <p>
                A class should have one,
                and only one, reason to change. meaning that a class should have only one job.It is very important to follow the
                principle of Single Responsibility .It is always easier to test one thing at a time, one
                function at a time.It is very important that the name of the function should be very descriptive as to the action it it
                performs.For example, when many different teams are working on the same project and keep editing
                the same class for different reasons, this can lead to incompatible modules.This also makes
                version control easier. Merge conflicts are another excellent example of this. They appear when different teams
                change the same file. But if the SRP is followed, fewer conflicts will appear – files will have
                a single reason to change, and conflicts that do exist will be easier to resolve.


                Let us look at the example<br>


                <code>Class User:<br>

                    &nbsp; def __init__(self, num1, num2):<br>
                    &nbsp; &nbsp; self.num1 = num1<br>
                    &nbsp; &nbsp; self.num2 = num2<br>
                    &nbsp; &nbsp; return num1+num2<br>

                    def add(self):<br>
                    &nbsp; pass<br>

                    def save(self):<br>
                    # saves to database
                    &nbsp; pass</code><br>

                In the above code snippet, the user class not only gets the user but also saves him in a
                database. The class handles both setting user data requirements and database connection and
                saving. We ought to have a User class that handles the user data and a database class that
                handles the DB connection and transactions.

            </p>
            <h2>Open-closed Principle </h2>

            <p>
                This means that a class should be extendable without modifying the class itself,that is,
                such an entity can allow its behaviour to be extended without modifying its source
                code.The implementations of an interface are independent of each other and don’t need to
                share any code. If you consider it an advantage that two implementations of an interface
                share some code, you can either use inheritance or composition.We should be able to add
                new functionality without touching the existing code for the class. This is because
                whenever we modify the existing code, we are taking the risk of creating potential bugs.
                .
                .We can
                should try adding a  new functionality without touching the  existing class with the help of interfaces and abstract
                classes.Here , let us explain this with the example of a calculator
                We can have one function to add two numbers and another function to add a list of
                numbers
                <code>
                    total = 0 <br>
                    mylist = [11, 5, 17, 18, 23]<br>
                    for ele in range(0, len(mylist)):<br>
                    total = total + mylist[ele]<br></code><br>
                Snce the above code is to add a list of numbers and ,when in a different method and the changes are made , it wouldn't affect the addition method


            </p>
            <h2>The Liskov Substitution Principle </h2>
            <p>
                It states that subclasses should be substitutable for their
                base classes. Given that class B is a subclass of class A, we should be able to pass an
                object of class B to any method that expects an object of class A and the method should
                not give any incorrect output in that case.when we use inheritance we assume that the
                child class inherits everything that the superclass has. The child class extends the
                behavior but never narrows it down.

                Therefore, when a class does not obey this principle, it leads to inconsistency in code

                Lets explain this with the example of a Calculator <br>
                <code>class Calculator:<br>

                    &nbsp; def calculate(self, a, b):<br>
                    &nbsp; &nbsp; return a * b <br>

                    class Divide(Calculator):<br>

                    &nbsp; def calculate(self, a, b):<br>
                    &nbsp; &nbsp; return a / b</code><br><br>
                In the above example, the two classes, even though the calculate methods take equal no of
                arguments, the method in the Divide class could possibly throw a divide by zero error which
                isn’t a possibility in its parent class (Calculator class) hence a violation of SOLID
                principles.

            </p>
            <h2>Interface segregation Principle </h2>
            <p>
                Segregation means keeping things separated, and the Interface
                Segregation Principle is about separating the interfaces.According to this principle,t
                many client-specific interfaces are better than one general-purpose interface. Clients
                should not be forced to implement a function they do no need.
                Let us take the example of a Calculator,
                multiplication extends calculation .
            </p>
            <h2>Dependency Inversion Principle </h2>
            <p>
                The Dependency Inversion principle states that our classes
                should depend upon interfaces or abstract classes instead on the concrete classes and
                functions.Entities must depend on abstractions, not on concretions.In another words,
                this can be explained asthe high-level module must not depend on the low-level module,
                but they should depend on abstractions.Let us again take the example of a calculator to demonstrate this
                lets take example of calculator:
                <code>class Calculator:<br>


                    """ This class is a collection of calculator functions """<br>
                    &nbsp; result = 0<br>
                    &nbsp; num_a = 0<br>
                    # Addition of two numbers<br>
                    &nbsp; def add(self, num1_a, num2_b):<br>
                    """ Function to add two numbers """<br>
                    &nbsp; &nbsp; self.num_a = num1_a<br>
                    &nbsp; &nbsp; self.result = self.num_a + num2_b<br>
                    &nbsp; &nbsp; return self.result<br><br>
                    </code>
                Adding a new operation to our current Calculator
                class will modify the current class. This modification will break the Open close principle
                of the SOLID principles. So,inorder to add new operations (or “extend”) our Calculator class
                without actually doing code changes (or “modifications”) to it,Dependency Inversion
                Principle helps.

                <img src="images/dependency.jpg" alt="image">

            </p>




        </div>
    </div>


</article>
<!-- Footer -->
<div class="footer">
    <a href="https://github.com/aad84/internet-history.git" rel="nofollow" title="Ayush Deshpande Github">Ayush Deshpande &#169;</a>
    <a href="http://validator.w3.org/check/referer" rel="nofollow" title="Validate as HTML5"><img alt="w3c" class="responsive" src="images/w3cicon.png" style="padding: 0"></a>
</div>
</body>
</html>